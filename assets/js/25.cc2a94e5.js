(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{390:function(s,o,e){"use strict";e.r(o);var n=e(40),t=Object(n.a)({},(function(){var s=this.$createElement,o=this._self._c||s;return o("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[o("h1",{attrs:{id:"token-session-cookie"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#token-session-cookie"}},[this._v("#")]),this._v(" token/session/cookie")]),this._v(" "),o("p",[this._v("都是为了管理会话，区分客户端。\n服务器通过算法和密匙对客户端的信息进行处理，生成一个签名，把签名和客户端信息一起保存成一个token发回客户端，下次客户端请求服务器时就带上这个token。服务器根据客户端的信息再次进行处理，和token中的签名进行对比验证。\n由于token将签名保存在自身中，服务器只通过算法和密匙对签名进行验证，不保存token，所以token是无状态，可扩展的，负载均衡器可以把对用户的服务转移到另一台服务器，而不会出现会话丢失的状况，同时也可以随意扩展服务器集群的数量，用验证签名的cpu时间换取了存储空间。\nsession翻译过来就是会话，是一个抽象的概念，客户端向服务器发起一段会话，服务器端就会创建相应的一个session保存起来，将session id即会话标识保存进cookie里，发回客户端。\ncookie是客户端保存session id的默认方式，如果通过cookie保存token，cookie只是一种存储机制，验证还是由token起作用。如果客户端不支持cookie，就通过重写URL的方式，将session id重写进URL里发送给客户端，或者使用token。\nsession一般失效时间较短，客户端关闭页面或者超过有效时间session就失效了。\ncookie一般大小不超过4kb，使用ASCII编码方式。")])])}),[],!1,null,null,null);o.default=t.exports}}]);