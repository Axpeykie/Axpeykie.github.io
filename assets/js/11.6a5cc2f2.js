(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{376:function(t,s,a){"use strict";a.r(s);var r=a(40),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("没有明确规定promise是microtask，但大家都默认这样做，因为如果把promise当做task，可能会产生一些性能问题，比如和task相关的一些操作如渲染更新等而导致回调函数被延迟调用，这是不必要的，和其他task的互相影响也带来了不确定性，而且有可能中断和一些API的交互。")]),t._v(" "),a("h2",{attrs:{id:"task-microtask"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task-microtask"}},[t._v("#")]),t._v(" task microtask")]),t._v(" "),a("p",[t._v("microtask 微任务，在当前任务task结束前执行（这点有错误，微任务执行并不仅限于当前task即将结束时")]),t._v(" "),a("p",[t._v("突变监听函数、promise属于微任务")]),t._v(" "),a("p",[t._v("任务队列tasks、微任务队列microtasks")]),t._v(" "),a("p",[t._v("微任务被加入微任务队列后，只要调用栈被情空就会立即执行回调")]),t._v(" "),a("p",[t._v("主动调用点击事件，只有在事件冒泡阶段完全结束，回调函数销毁后，才会接下去执行下面的代码。")]),t._v(" "),a("p",[t._v("疑问？每一个任务task结束时必须保证调用栈清空吗？")])])}),[],!1,null,null,null);s.default=e.exports}}]);