(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{379:function(v,_,t){"use strict";t.r(_);var a=t(40),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"数据结构和算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法"}},[v._v("#")]),v._v(" 数据结构和算法")]),v._v(" "),t("h2",{attrs:{id:"数据结构和算法的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法的关系"}},[v._v("#")]),v._v(" 数据结构和算法的关系")]),v._v(" "),t("p",[v._v("数据结构是描述数据储存方式的学科，一块数据通过怎样的方式储存，图？链表？还是树？这些即是数据结构的研究范围。合理选择数据结构是非常重要的。而算法是基于数据结构的解决问题的具体步骤。")]),v._v(" "),t("h2",{attrs:{id:"几种基本的数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几种基本的数据结构"}},[v._v("#")]),v._v(" 几种基本的数据结构")]),v._v(" "),t("ol",[t("li",[v._v("Trie树")]),v._v(" "),t("li",[v._v("链表")]),v._v(" "),t("li",[v._v("队列")]),v._v(" "),t("li",[v._v("栈")]),v._v(" "),t("li",[v._v("堆")]),v._v(" "),t("li",[v._v("数组")]),v._v(" "),t("li",[v._v("散列表")]),v._v(" "),t("li",[v._v("二叉树")]),v._v(" "),t("li",[v._v("跳表")]),v._v(" "),t("li",[v._v("图")])]),v._v(" "),t("h2",{attrs:{id:"几种基本的算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几种基本的算法"}},[v._v("#")]),v._v(" 几种基本的算法")]),v._v(" "),t("ol",[t("li",[v._v("递归")]),v._v(" "),t("li",[v._v("排序")]),v._v(" "),t("li",[v._v("二分查找")]),v._v(" "),t("li",[v._v("搜索")]),v._v(" "),t("li",[v._v("哈希算法")]),v._v(" "),t("li",[v._v("贪心算法")]),v._v(" "),t("li",[v._v("分治算法")]),v._v(" "),t("li",[v._v("回溯算法")]),v._v(" "),t("li",[v._v("动态规划")]),v._v(" "),t("li",[v._v("字符串匹配")])]),v._v(" "),t("h1",{attrs:{id:"详情"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#详情"}},[v._v("#")]),v._v(" 详情")]),v._v(" "),t("h3",{attrs:{id:"选择排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[v._v("#")]),v._v(" 选择排序")]),v._v(" "),t("p",[v._v("一个长度为n的数组，每遍历一次这个数组选出一个最小或最大的值，把这个值加入到新数组中，对剩下的n-1个数再进行遍历，直到这个数组的长度为0，最终得到一个有序排列的新数组。")]),v._v(" "),t("p",[v._v("时间复杂度：O(n"),t("sup",[v._v("2")]),v._v(")")]),v._v(" "),t("h3",{attrs:{id:"快速排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[v._v("#")]),v._v(" 快速排序")]),v._v(" "),t("p",[v._v("选取一个基准值，把小于基准值的数放到一边，大于基准值的数放到另一边，对两边的数组进行同样的操作，最后得到一个有序数组。思想：分而治之；方法：递归。")]),v._v(" "),t("p",[v._v("时间复杂度：平均(最佳)情况为O(nlogn) 最糟情况为O(n"),t("sup",[v._v("2")]),v._v(") 可以通过随机选择基准值来使每次输入都能得到较好的效果。")]),v._v(" "),t("p",[v._v("空间复杂度：O(logn) 即递归调用的栈高度")]),v._v(" "),t("h3",{attrs:{id:"冒泡排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[v._v("#")]),v._v(" 冒泡排序")]),v._v(" "),t("p",[v._v("遍历数组每一个值，把前一个值和后一个值比较，如果前一个值比后一个值大就将他们俩换位。遍历一次数组后数组末尾的值会是最大的值。再对前面的n-1个元素进行相同的操作，每次遍历将最大的值移到最后。")]),v._v(" "),t("h3",{attrs:{id:"数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")])])}),[],!1,null,null,null);_.default=s.exports}}]);