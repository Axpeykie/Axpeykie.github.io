<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>执行上下文 | Axpeykie&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="share!">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.65ca9bb5.js" as="script"><link rel="preload" href="/assets/js/2.14a13fa9.js" as="script"><link rel="preload" href="/assets/js/12.90aa9cb7.js" as="script"><link rel="prefetch" href="/assets/js/10.2f94525b.js"><link rel="prefetch" href="/assets/js/11.6a5cc2f2.js"><link rel="prefetch" href="/assets/js/13.475ad283.js"><link rel="prefetch" href="/assets/js/14.6cb0a9fd.js"><link rel="prefetch" href="/assets/js/15.7b3ce09f.js"><link rel="prefetch" href="/assets/js/16.f0a5d30e.js"><link rel="prefetch" href="/assets/js/17.ea63d749.js"><link rel="prefetch" href="/assets/js/18.b5af9e97.js"><link rel="prefetch" href="/assets/js/19.7e6f0376.js"><link rel="prefetch" href="/assets/js/20.b943776b.js"><link rel="prefetch" href="/assets/js/21.cd936ef8.js"><link rel="prefetch" href="/assets/js/22.66334dda.js"><link rel="prefetch" href="/assets/js/23.49c91fd5.js"><link rel="prefetch" href="/assets/js/24.f58389e9.js"><link rel="prefetch" href="/assets/js/25.cc2a94e5.js"><link rel="prefetch" href="/assets/js/26.07102b13.js"><link rel="prefetch" href="/assets/js/27.50cef554.js"><link rel="prefetch" href="/assets/js/28.f5f36556.js"><link rel="prefetch" href="/assets/js/29.6a3fa8c9.js"><link rel="prefetch" href="/assets/js/3.32769151.js"><link rel="prefetch" href="/assets/js/30.8d82b854.js"><link rel="prefetch" href="/assets/js/4.63745a10.js"><link rel="prefetch" href="/assets/js/5.e36bd015.js"><link rel="prefetch" href="/assets/js/6.1017c97b.js"><link rel="prefetch" href="/assets/js/7.b60ae1a9.js"><link rel="prefetch" href="/assets/js/8.2523b28c.js"><link rel="prefetch" href="/assets/js/9.aa7b199d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Axpeykie's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博文" class="dropdown-title"><span class="title">博文</span> <span class="arrow down"></span></button> <button type="button" aria-label="博文" class="mobile-dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/" class="nav-link router-link-active">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/network/" class="nav-link">
  网络通信
</a></li><li class="dropdown-item"><!----> <a href="/vue.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/算法/" class="nav-link">
  算法
</a></li></ul></div></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博文" class="dropdown-title"><span class="title">博文</span> <span class="arrow down"></span></button> <button type="button" aria-label="博文" class="mobile-dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/" class="nav-link router-link-active">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/network/" class="nav-link">
  网络通信
</a></li><li class="dropdown-item"><!----> <a href="/vue.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/算法/" class="nav-link">
  算法
</a></li></ul></div></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/js/闭包.html" class="sidebar-link">闭包</a></li><li><a href="/js/节流防抖.html" class="sidebar-link">节流防抖</a></li><li><a href="/js/类型判断.html" class="sidebar-link">类型判断</a></li><li><a href="/js/模拟call、apply、bind.html" class="sidebar-link">模拟call、apply、bind</a></li><li><a href="/js/模拟call和apply详解.html" class="sidebar-link">模拟call和apply详解</a></li><li><a href="/js/模拟new.html" class="sidebar-link">模拟new</a></li><li><a href="/js/深浅拷贝.html" class="sidebar-link">深浅拷贝</a></li><li><a href="/js/事件循环.html" class="sidebar-link">事件循环</a></li><li><a href="/js/数据结构和算法.html" class="sidebar-link">数据结构和算法</a></li><li><a href="/js/原型原型链.html" class="sidebar-link">原型原型链</a></li><li><a href="/js/作用域执行上下文.html" class="active sidebar-link">作用域执行上下文</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#执行上下文" class="sidebar-link">执行上下文</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#创建执行上下文" class="sidebar-link">创建执行上下文</a></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#执行阶段" class="sidebar-link">执行阶段</a></li></ul></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#词法环境-2" class="sidebar-link">词法环境</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#作用域-一个通用的理论概念" class="sidebar-link">作用域——一个通用的理论概念</a></li></ul></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#标识符绑定" class="sidebar-link">标识符绑定</a></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#激活记录模型" class="sidebar-link">激活记录模型</a></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#环境" class="sidebar-link">环境</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#环境的定义" class="sidebar-link">环境的定义</a></li></ul></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#函数创建和调用" class="sidebar-link">函数创建和调用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#函数创建" class="sidebar-link">函数创建</a></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#函数调用" class="sidebar-link">函数调用</a></li></ul></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#函数式参数问题" class="sidebar-link">函数式参数问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#一类函数" class="sidebar-link">一类函数</a></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#函数式参数" class="sidebar-link">函数式参数</a></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#高阶函数" class="sidebar-link">高阶函数</a></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#自由变量" class="sidebar-link">自由变量</a></li></ul></li><li class="sidebar-sub-header"><a href="/js/作用域执行上下文.html#通用理论总结" class="sidebar-link">通用理论总结</a></li></ul></li><li><a href="/js/defineProperty.html" class="sidebar-link">defineProperty</a></li><li><a href="/js/this.html" class="sidebar-link">this</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h2> <h4 id="什么是执行上下文"><a href="#什么是执行上下文" class="header-anchor">#</a> 什么是执行上下文？</h4> <p>执行上下文，是评估和运行js代码的环境的抽象概念。</p> <h4 id="执行上下文的种类"><a href="#执行上下文的种类" class="header-anchor">#</a> 执行上下文的种类</h4> <ol><li>全局执行上下文。<br>
一个程序只会有一个全局上下文，也可以说是基本或者默认的上下文。任何不在函数内部的代码都处于全局上下文中。在浏览器环境下它将创建一个window对象，并将this指向这个对象。</li> <li>函数执行上下文。<br>
每当一个函数被调用的时候，就会创建一个属于这个函数的上下文，在这个上下文中执行函数。</li> <li>Eval函数执行上下文。<br>
暂略。</li></ol> <h4 id="执行栈"><a href="#执行栈" class="header-anchor">#</a> 执行栈</h4> <p>即调用栈。执行栈的最底部是全局执行上下文，每遇到一个函数调用就为其创建一个函数执行上下文并压入栈顶，执行完毕后从栈中弹出，所有代码执行完毕后引擎从栈中移除全局执行上下文。</p> <h3 id="创建执行上下文"><a href="#创建执行上下文" class="header-anchor">#</a> 创建执行上下文</h3> <p>创建执行上下文的过程会发生三件事：</p> <ol><li>this的决定</li> <li>创建词法环境组件</li> <li>创建变量环境组件</li></ol> <h4 id="this"><a href="#this" class="header-anchor">#</a> this</h4> <p>this的指向分两种情况。当在全局执行上下文时，this指向一个window对象。当在函数执行上下文时，this指向调用函数的对象。严格模式下，全局执行上下文中的this是undefined</p> <h4 id="词法环境"><a href="#词法环境" class="header-anchor">#</a> 词法环境</h4> <p><strong>什么是词法环境？</strong><br>
简单地说，词法环境就是持有标识符——变量映射的结构。注意此处的标识符是指变量、函数等的名字，而变量指对数据的引用。<br> <strong>词法环境的类型</strong><br> <strong>全局词法环境</strong>：包含对象环境记录器，外部环境引用（null）<br> <strong>函数词法环境</strong>：包含声明式环境记录器，外部环境引用（全局环境或者包含此函数的外部函数）<br>
对象环境记录器用来定义出现在全局上下文中的函数和变量的关系，而声明式环境记录器存储变量、函数和参数，以及一个传递给函数的arguments对象（包含传递给函数的参数的length）</p> <p>关系表如下：</p> <table><thead><tr><th style="text-align:center;">词法环境:</th> <th style="text-align:center;">全局环境</th> <th style="text-align:center;">函数环境</th></tr></thead> <tbody><tr><td style="text-align:center;">环境记录器:</td> <td style="text-align:center;">对象环境记录器</td> <td style="text-align:center;">声明式环境记录器</td></tr> <tr><td style="text-align:center;">外部引用:</td> <td style="text-align:center;">null</td> <td style="text-align:center;">全局环境或包含该函数的外部函数</td></tr></tbody></table> <h4 id="变量环境"><a href="#变量环境" class="header-anchor">#</a> 变量环境</h4> <p><strong>什么是变量环境？</strong><br>
变量环境也是词法环境，所以拥有上述的所有属性。<br> <strong>变量环境和词法环境的不同：</strong><br>
变量环境记录器和词法环境记录器都用来存储变量的声明语句，但是，词法环境记录器存储let、const和函数的声明，变量环境记录器存储var的声明。<br>
在执行上下文的创建阶段，let和const的声明没有关联任何值，而var的声明关联了undefined值，这就是为什么可以在对var变量赋值前访问它，而同样访问let和const变量会报错，这就是变量声明提升。</p> <h3 id="执行阶段"><a href="#执行阶段" class="header-anchor">#</a> 执行阶段</h3> <p>执行阶段，完成对变量的分配，最后执行代码。<br>
如果引擎在let的声明位置没有找到实际的值，let变量会被赋值为undefined</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> a<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//undefined</span>
a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>
</code></pre></div><p>以上理解来自：</p> <p>2018-09-20 https://juejin.cn/post/6844903682283143181#heading-9</p> <h2 id="词法环境-2"><a href="#词法环境-2" class="header-anchor">#</a> 词法环境</h2> <p>词法环境理论在很多语言中都存在，因此独立于ECMA标准理论概念。<br>
相比于ES3中的变量对象、激活对象、作用域链等概念，词法环境更加抽象，也建议使用词法环境概念替代前者的描述。</p> <h3 id="作用域-一个通用的理论概念"><a href="#作用域-一个通用的理论概念" class="header-anchor">#</a> 作用域——一个通用的理论概念</h3> <h4 id="什么是作用域"><a href="#什么是作用域" class="header-anchor">#</a> 什么是作用域？</h4> <p>作用域用来管理一个程序中不同部分变量和函数声明的可见性和生命周期，即对某个变量或方法具有访问权限的<strong>代码空间</strong>。<br>
作用域是封闭上下文，让我们能在程序中使用具有相同命名的不同变量。<br>
同时也是逻辑边界。如全局变量和局部变量，两者的分类代表了其生命周期的逻辑边界。<br>
作用域的特性：它是一种嵌套结构。（包含与被包含）<br>
ES6之前只有全局作用域和函数作用域，没有块级作用域。要实现块级作用域，只能通过立即执行函数IIFE或者try-catch语句。（ES6向ES5转换时，正是通过try-catch语法实现块级作用域）</p> <h4 id="作用域类型"><a href="#作用域类型" class="header-anchor">#</a> 作用域类型</h4> <p>静态（词法）作用域和动态作用域。</p> <h5 id="词法作用域"><a href="#词法作用域" class="header-anchor">#</a> 词法作用域</h5> <p>词法：指程序上下文的一个属性，词法意义上的位置就是定义时所处的实际位置。<br>
词法变量：采用词法作用域的变量。<br>
环境：定义处周围的词法内容，即定义周围的代码块。<br>
自由变量：函数内部遇到的，既不是形参，也不是在函数内定义的局部变量的变量，叫做自由变量。</p> <p>静态代表着一个标识符所在的作用域和它的含义在程序解析阶段就被确定，所以一个变量定义在哪，就被约束于哪个作用域，这就是静态作用域。同时静态作用域也约束了自由变量的引用，在函数中遇到了自由变量，那么应该到定义函数的作用域中去查找这个变量。假如没有找到，就到更外围的作用域去查找。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10, 20 </span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10, 30</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10, 20</span>
<span class="token punctuation">}</span> 
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的例子中，foo是在全局作用域中定义的，所以当函数运行时遇到自由变量x和y，就会到函数定义时的作用域即全局作用域查找。<br>
词法作用域的优先级：可以看到，bar内部声明的y变量覆盖了外部的同名全局变量，因为包含变量定义的词法作用域拥有最高优先级。</p> <p><strong>总结：对于静态作用域，变量或函数所在的词法环境在定义时就被确定，是静态的，不变的，不会随着运行动态绑定。词法作用域中的函数遇到自由变量，到定义了这个函数的作用域查找。</strong></p> <p>使用静态作用域的语言：C,Java,ECMAScript, Python, Ruby, Lua等等<br>
以上理解来自：<br>
词法环境：通用理论https://blog.csdn.net/szengtal/article/details/78721665</p> <h5 id="动态作用域"><a href="#动态作用域" class="header-anchor">#</a> 动态作用域</h5> <p>今天大部分主流编程语言不使用动态作用域。<br>
动态作用域无法为变量创建闭包。<br>
动态作用域会假设变量与值的关系不能在解析阶段被确定。变量和值不在词法环境中绑定，而是通过一个全局的动态变量栈来管理。每遇到一个变量声明，就把它压入栈顶，生命周期结束后弹出。调用者的环境将影响变量的解析。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// *pseudo* code – 使用动态作用域</span>
y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
procedure <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
end 
 
<span class="token comment">// 在当前的全局变量栈上，变名为y的变量</span>
<span class="token comment">// 当前只拥有一个值20</span>
<span class="token comment">// {y: [20]} </span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 20, OK </span>
procedure <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token comment">//在这里变量栈上拥有两个y值{y: [20, 30]};</span>
  <span class="token comment">//首先使用的是栈顶的</span>
y <span class="token operator">=</span> <span class="token number">30</span> 
  <span class="token comment">// 因此:</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 30!, not 20</span>
end 
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的伪代码很好的表现了动态作用域的特点。它不关心函数在哪里定义，只关心函数在哪里调用。<strong>动态作用域的作用域链基于调用栈，静态作用域的作用域链基于作用域嵌套。</strong></p> <p>以上理解来自：<br>
词法环境——通用理论https://blog.csdn.net/szengtal/article/details/78722483</p> <h2 id="标识符绑定"><a href="#标识符绑定" class="header-anchor">#</a> 标识符绑定</h2> <p>即将一个标识符和一个对象绑定在一起。与绑定相关的两个操作分别是重绑定和改变。</p> <h4 id="重绑定"><a href="#重绑定" class="header-anchor">#</a> 重绑定</h4> <p>将一个标识符从旧的对象上解除绑定，重新绑定到新的对象上。在ECMAscript中可以通过简单的赋值操作实现重绑定。<br>
按共享传递：可以理解为一种特殊的按值传递，这个值是一个地址。当一个变量绑定了一个对象，把这个变量赋值给另一个变量时，仅仅是把对象的地址拷贝了一份赋值给第二个变量，因此这两个变量绑定了同一个对象。这就叫共享传递。ECMAscript中，当函数参数是引用类型时，使用的就是共享传递。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   
   obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;peter&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">setName</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// perter</span>
</code></pre></div><h4 id="变动"><a href="#变动" class="header-anchor">#</a> 变动</h4> <p>重绑定是将变量指向一个新的内存空间，而变动是在原来的内存空间上对内容进行修改。</p> <p>以上理解来自：<br>
词法环境：通用理论https://blog.csdn.net/szengtal/article/details/78722559</p> <h2 id="激活记录模型"><a href="#激活记录模型" class="header-anchor">#</a> 激活记录模型</h2> <p>激活记录，又叫栈帧，是调用栈中的一种特殊数据结构。<br>
激活记录被用来存储环境绑定。（包括形参和局部变量）<br>
每当一个函数被激活（调用），就有一个激活记录被push到调用栈，函数返回后从栈中pop出。同时激活记录内的局部变量也被销毁。</p> <p>ECMAScript中，调用栈被称为执行上下文栈，激活记录被称为激活对象（只在ES3中，ES5后激活对象这一概念被统一到环境模型中去）</p> <p>ECMAScript管理函数执行的方式和以上方法逻辑相同，但具有很重要的不同点：当函数中存在闭包时，函数结束后，激活对象将不会从内存中销毁。ECMAScript中的激活对象不是存储在栈中而是堆中（基于堆），并且如果情况需要，所以的父级活动对象都会被存储。</p> <p>类比于栈帧，ECMAScript中的激活对象被称为环境帧，与栈帧相区别。上述的存储过程可以这样表达：如果闭包引用了环境帧的内容，那么环境帧在函数结束后将继续存在。基于栈的活动记录的语言，如c语言，是无法做到这点的。以下的例子可以帮助更好的理解环境帧的概念。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//环境帧</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//闭包引用了来自环境帧的内容</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span>
</code></pre></div><h2 id="环境"><a href="#环境" class="header-anchor">#</a> 环境</h2> <h3 id="环境的定义"><a href="#环境的定义" class="header-anchor">#</a> 环境的定义</h3> <p>一个环境就是框架的一个序列，每个框架是包含着一些变量绑定的一个记录（可能为空）。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Global environment (GE)</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//通过函数“foo”创建的环境(E1)</span>
  <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
 
  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过函数“bar”创建的环境( (E2)</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z <span class="token operator">+</span> q<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token comment">// 将“bar”返回到外部</span>
  <span class="token keyword">return</span> bar<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>
</code></pre></div><p>上面的例子中有三个环境，GE，E1，E2。对应全局环境，foo函数环境，bar函数环境。<br>
GE环境有一个框架，就是它自己，全局框架。<br>
E1环境有两个框架，foo和全局框架。<br>
E2环境有三个框架，bar，foo和全局框架。</p> <p>一个框架内，任何变量至多有一个绑定。<br>
每一个框架有一个指向外围环境的指针。<br>
全局框架的外围环境是null。<br>
这些连起来的指针，或者说环境框架的序列就形成了作用域链。<br>
一个变量在整个序列中都没有绑定，那么称这个变量是无约束的。</p> <hr> <p>[^这一段在阅读完函数创建和调用后再看]:</p> <p>对于bar来说，x，y，z都是自由变量，因此需要到创建了bar函数的环境中去查找，找不到就再往上层环境查找。其实可以这样理解，bar在创建时生成了函数对象，而这个对象就保存了上层环境（即foo），因此可以找到foo里的变量。而foo本身没有使用自由变量，但由于bar使用到了自由变量x，且bar是在foo内部定义的，所以foo保存了foo外部的绑定信息，并将关于x绑定的信息传给深层的函数（即函数bar）</p> <hr> <h2 id="函数创建和调用"><a href="#函数创建和调用" class="header-anchor">#</a> 函数创建和调用</h2> <h3 id="函数创建"><a href="#函数创建" class="header-anchor">#</a> 函数创建</h3> <p>函数对象：函数在词法环境中创建后就生成相应的函数对象，无论该函数是否会被调用。<br>
函数对象是一组由函数体和创建该函数的环境的指针的对偶。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// global &quot;x&quot;</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 
<span class="token comment">// 函数&quot;foo&quot;创建在全局环境下</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
通过伪代码来看生成的函数对象

<span class="token comment">// create &quot;foo&quot; function</span>
 
foo <span class="token operator">=</span> functionObject <span class="token punctuation">{</span>
  code<span class="token operator">:</span> <span class="token string">&quot;console.log(x + y + z);&quot;</span>      <span class="token comment">//函数体</span>
  environment<span class="token operator">:</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> outer<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span>    <span class="token comment">//创建该函数的环境</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>一旦函数在词法环境中被创建，就生成对应的函数对象，存储函数体和外部环境的信息。</strong><br>
从这个角度看，ECMAScript中所有的函数都是闭包，因为从被创建起就保存了上层环境。</p> <h3 id="函数调用"><a href="#函数调用" class="header-anchor">#</a> 函数调用</h3> <p>函数被调用时将建立一个新环境，包含所有形参实参，以及存储函数局部变量绑定的框架。</p> <h2 id="函数式参数问题"><a href="#函数式参数问题" class="header-anchor">#</a> 函数式参数问题</h2> <p>首先了解以下几个概念：</p> <h3 id="一类函数"><a href="#一类函数" class="header-anchor">#</a> 一类函数</h3> <p>第一类函数指可以像普通数据一样赋值给其他变量或结构，可以在运行时用字面量创建，可以作为参数传递，可以作为返回值从其他函数返回的函数。ECMAScript中所有函数都是一类函数。</p> <h3 id="函数式参数"><a href="#函数式参数" class="header-anchor">#</a> 函数式参数</h3> <p>当函数被作为参数传入另一个函数时，这个参数就叫函数式参数。</p> <h3 id="高阶函数"><a href="#高阶函数" class="header-anchor">#</a> 高阶函数</h3> <p>接收函数式参数的函数，称为高阶函数。</p> <h3 id="自由变量"><a href="#自由变量" class="header-anchor">#</a> 自由变量</h3> <p>既不是形参也不是函数内部定义的局部变量的变量，称为自由变量。</p> <h4 id="第一类问题"><a href="#第一类问题" class="header-anchor">#</a> 第一类问题</h4> <blockquote><p>一个内部函数作为返回值从它的父函数被返回。当这个内部函数使用了来自创建它的父函数的自由变量，在父函数运行结束后（父函数的环境被销毁），这个返回的内部函数该如何继续访问那些父函数中的自由变量？</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&amp;</span>emsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>emsp<span class="token punctuation">;</span><span class="token function">看下面例子：</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span>
</code></pre></div><p>答案：词法作用域中，会将函数的上层环境框架存在堆里。</p> <h4 id="第二类问题"><a href="#第二类问题" class="header-anchor">#</a> 第二类问题</h4> <blockquote><p>一个使用自由变量的函数被作为参数传递给另外一个函数时，这个参数函数使用的自由变量应该去哪查找，是这个参数函数定义时所在的作用域还是执行这个参数函数所在的作用域?</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">funArg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  <span class="token function">funArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10, not 20</span>
 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 创建一个参数函数</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自由变量x</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>答案：由于静态作用域，会到函数定义时所在的作用域查找。</p> <h2 id="通用理论总结"><a href="#通用理论总结" class="header-anchor">#</a> 通用理论总结</h2> <ol><li>环境的概念与作用域的概念有关。</li> <li>理论中有两种作用域类型：动态和静态（词法）作用域</li> <li>ECMAScript使用静态（词法）作用域
然而，with和eval语法可以为静态作用域带来动态性。</li> <li>诸如作用域，环境，激活对象，激活记录，栈帧，环境帧，环境记录甚至执行上下文等概念—都是用于讨论的近义词（译注:为什么会用这些词，原文以及译注中都有提及）。因此，从ECMAScript的技术角度来说，它们中的一些是另一个的一部分—例如，一个环境记录项是词法环境的一部分，而词法环境又是执行环境的一部分。然而，从逻辑上来收，它们这些抽象定义几乎可以互换使用。因此下面哪一个都是正常的称呼：“全局作用域”，“全局环境”，“全局上下文”，等等。</li> <li>ECMAScript使用链式环境框架模型，在ES3中被称为作用域链。在ES5中环境框架被叫做环境记录项。</li> <li>一个环境可以被多个内部环境当做它们的外层环境。</li> <li>词法环境被用来实现闭包，以及解决了函数式参数的问题。</li> <li>ECMAScript中所有函数都是一类函数</li></ol> <p>以上理解来自：<br>
词法环境：通用理论https://blog.csdn.net/szengtal/article/details/78722826</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js/原型原型链.html" class="prev">
        原型原型链
      </a></span> <span class="next"><a href="/js/defineProperty.html">
        defineProperty
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.65ca9bb5.js" defer></script><script src="/assets/js/2.14a13fa9.js" defer></script><script src="/assets/js/12.90aa9cb7.js" defer></script>
  </body>
</html>
